#!/usr/bin/perl -W
# This supports ipv6 (if available) unlike the brooklyn_server script.
use CGI;
use LWP;
use YAML::Syck;
use Tie::IxHash; # May need to tie interfaces for the http server module
use Net::Domain;
use Net::Server::HTTP;	# This returns a 5xx code if a uri without HTTP/.. code is received, but our brooklyn/vips healthcheck always sends at least an HTTP/1.0 with Host: IP
use Range;


my $b_checkfile = '/tmp/b_checkfile';

my $res = Net::Server::HTTP->run(
	port => 8081,
	ipv  => '*',		# both ipv6 and ipv4
	app  => {
		'/status.cgi'           => \&resp_checker,
	},
	app => {
		'/healthcheck.cgi'      => \&resp_checker,
	},

	app => {
		'/'                         => \&resp_404,
	},
	# Create this before running in the runscript, chown it to nobody
	#access_log_file => '/var/log/b_access.log',
	access_log_file               => STDERR,	# Let daemontools do the logging
);

sub resp_404 {
	my $cgi = new CGI;
	print $cgi->header(
                        -status        => "404 Not found",
                        -pragma        => "must-revalidate, no-cache, no-store, expires: -1",
                        -no_cache      => 1,
                        -expires       => -1,
                        -cache_control => "no-cache, no-store, must-revalidate",
                        -content_type  => 'text/plain',
                      );
	print "Not found$/";
	return;
}

sub resp_checker {
	# This is where we perform some tests and returns HTTP error codes based on the outcome.
	# Ideally we should just read the checks from a yaml file and run them one by one.
	my $cgi   = new CGI;
	my $brooklyn_status;

	my $cache = '/tmp/b_cache.yaml';

	if ( -f $cache and -M $cache < 300 ) {
		my $data = YAML::Syck::LoadFile($cache);

		unless($data) {
			warn "Unable to read from $cache\n";
			unlink($cache);
		}

		my $cluster = $data->{cluster};
		my $bstatus = $data->{bstatus};
		$brooklyn_status = $bstatus;
	}
	else {
		my $sdr = Range->new();
		my $host = Net::Domain::hostfqdn();
		my @cluster = $sdr->expand('*'.$host);
		warn $sdr->last_err if $sdr->last_err;

		die "Unable to determine cluster\n"
			unless(@cluster);
		warn "More than one cluster found for $host\n"
			if (@cluster > 1);

		my $cluster   = $cluster[0];
		my ($bstatus) = $sdr->expand('%' . $cluster . ':B_STATUS');
		die "B status not found\n" unless($bstatus);

		my $data;
		$data->{cluster} = $cluster;
		$data->{bstatus} = $bstatus;
		YAML::Syck::DumpFile($cache,$data);
		$b_status = $bstatus;
	}


	# Check 1, IMMEDIATELY return 404 if $b_checkfile exists;
	if ( -f $b_checkfile ) {
		resp_404();
		return();		# resp_404 has a return(), but for some reason it does not.
	}

	# Return 0 or 1 based on some conditions;
	my $status = 1;

	# Load all these checks frmo a yaml config
	# Based on :B_STATUS key
	if(lc($b_status) eq 'up') {
		$status = 1;
	}
	elsif(lc($b_status) eq 'down') {
		$status = 0;
	}
	else {
		# By default, set failed
		$status = 0;
	}

	# based on lwp
	my $url   = 'http://127.0.0.1:10111/se';
	my $ua    = LWP::UserAgent->new();
	my $resp  = $ua->get($url);
	if ($resp->is_success()) {
		$status = $status && 1;
	}
	else {
		$status = 0;
	}

	# Add any tests here
	if ( $status == 1 ) {
    print $cgi->header(
                        -status        => "200 OK",
                        -pragma        => "must-revalidate, no-cache, no-store, expires: -1",
                        -no_cache      => 1,
                        -expires       => -1,
                        -cache_control => "no-cache, no-store, must-revalidate",
                        -content_type  => 'text/plain',
                      );
    print "Ok$/";
		return;
	}
    else {
    print $cgi->header(
                        -status        => "503 Unavailable",
                        -pragma        => "must-revalidate, no-cache, no-store, expires: -1",
                        -no_cache      => 1,
                        -expires       => -1,
                        -cache_control => "no-cache, no-store, must-revalidate",
                        -content_type  => 'text/plain',
                      );
    print "Unavailable$/";
    return;
  }
}
